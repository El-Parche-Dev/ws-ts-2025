# üéØ 06. Enhanced Validation

**‚è∞ Tiempo asignado**: 60 minutos (4:30 PM - 5:30 PM)  
**üéØ Objetivo**: Validaci√≥n robusta frontend + backend para producci√≥n  
**üìã Estrategia**: Form validation + API validation + UX feedback

---

## ‚è±Ô∏è TIMEBOXING ESTRICTO

| Fase            | Tiempo    | Objetivo                     | Status |
| --------------- | --------- | ---------------------------- | ------ |
| **üîß CORE**     | 0-25 min  | Backend validation completa  | ‚≠ê     |
| **‚ö° ENHANCED** | 25-50 min | Frontend validation + UX     | üöÄ     |
| **‚ú® POLISH**   | 50-60 min | Advanced patterns + security | üé®     |

---

## üîß FASE CORE (0-25 min) - Backend Validation

### ‚úÖ Objetivo: API validation robusta y consistente

**Validation Middleware (backend/middleware/validation.js):**

```javascript
// üéØ Validation utility functions
const validateTodoTitle = title => {
  const errors = [];

  if (!title) {
    errors.push('El t√≠tulo es requerido');
  } else {
    if (typeof title !== 'string') {
      errors.push('El t√≠tulo debe ser texto');
    } else {
      const trimmedTitle = title.trim();

      if (trimmedTitle.length < 3) {
        errors.push('El t√≠tulo debe tener al menos 3 caracteres');
      }

      if (trimmedTitle.length > 100) {
        errors.push('El t√≠tulo no puede exceder 100 caracteres');
      }

      // Check for invalid characters
      const invalidChars = /[<>\"'&]/;
      if (invalidChars.test(trimmedTitle)) {
        errors.push('El t√≠tulo contiene caracteres no permitidos');
      }
    }
  }

  return {
    isValid: errors.length === 0,
    errors,
    sanitized: title ? title.trim() : '',
  };
};

const validateTodoId = id => {
  const errors = [];
  const numId = parseInt(id);

  if (isNaN(numId)) {
    errors.push('ID debe ser un n√∫mero v√°lido');
  } else if (numId <= 0) {
    errors.push('ID debe ser un n√∫mero positivo');
  }

  return {
    isValid: errors.length === 0,
    errors,
    sanitized: numId,
  };
};

// üîß Validation middleware functions
const validateCreateTodo = (req, res, next) => {
  const { title } = req.body;

  const titleValidation = validateTodoTitle(title);

  if (!titleValidation.isValid) {
    return res.status(400).json({
      success: false,
      message: 'Datos de entrada inv√°lidos',
      errors: {
        title: titleValidation.errors,
      },
      field: 'title',
    });
  }

  // Sanitize and attach to request
  req.validatedData = {
    title: titleValidation.sanitized,
  };

  next();
};

const validateUpdateTodo = (req, res, next) => {
  const { id } = req.params;
  const { title, completed } = req.body;

  const errors = {};

  // Validate ID
  const idValidation = validateTodoId(id);
  if (!idValidation.isValid) {
    errors.id = idValidation.errors;
  }

  // Validate title if provided
  if (title !== undefined) {
    const titleValidation = validateTodoTitle(title);
    if (!titleValidation.isValid) {
      errors.title = titleValidation.errors;
    }
    req.validatedData = req.validatedData || {};
    req.validatedData.title = titleValidation.sanitized;
  }

  // Validate completed if provided
  if (completed !== undefined) {
    if (
      typeof completed !== 'boolean' &&
      completed !== 'true' &&
      completed !== 'false'
    ) {
      errors.completed = ['El estado debe ser verdadero o falso'];
    } else {
      req.validatedData = req.validatedData || {};
      req.validatedData.completed = Boolean(completed);
    }
  }

  // Check if we have any errors
  if (Object.keys(errors).length > 0) {
    return res.status(400).json({
      success: false,
      message: 'Datos de entrada inv√°lidos',
      errors,
    });
  }

  req.validatedData = req.validatedData || {};
  req.validatedData.id = idValidation.sanitized;

  next();
};

const validateTodoId = (req, res, next) => {
  const { id } = req.params;

  const idValidation = validateTodoId(id);

  if (!idValidation.isValid) {
    return res.status(400).json({
      success: false,
      message: 'ID inv√°lido',
      errors: {
        id: idValidation.errors,
      },
    });
  }

  req.validatedData = {
    id: idValidation.sanitized,
  };

  next();
};

// üîí Security middleware
const rateLimitByIP = (req, res, next) => {
  // Simple rate limiting simulation
  const ip = req.ip || req.connection.remoteAddress;
  const now = Date.now();

  if (!global.rateLimitStore) {
    global.rateLimitStore = new Map();
  }

  const clientData = global.rateLimitStore.get(ip) || {
    count: 0,
    lastRequest: now,
  };

  // Reset if more than 1 minute has passed
  if (now - clientData.lastRequest > 60000) {
    clientData.count = 0;
    clientData.lastRequest = now;
  }

  clientData.count++;

  if (clientData.count > 100) {
    // Max 100 requests per minute
    return res.status(429).json({
      success: false,
      message: 'Demasiadas solicitudes. Intente de nuevo en un minuto.',
      retryAfter: 60,
    });
  }

  global.rateLimitStore.set(ip, clientData);
  next();
};

module.exports = {
  validateCreateTodo,
  validateUpdateTodo,
  validateTodoId,
  rateLimitByIP,
  validateTodoTitle, // Export for testing
};
```

**Enhanced Server with Validation (backend/server.js):**

```javascript
const express = require('express');
const cors = require('cors');
const {
  validateCreateTodo,
  validateUpdateTodo,
  validateTodoId,
  rateLimitByIP,
} = require('./middleware/validation');

const app = express();
const PORT = process.env.PORT || 3001;

// Apply rate limiting globally
app.use(rateLimitByIP);

// Existing middleware...
app.use(cors(/* ... */));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Enhanced routes with validation
app.post('/api/todos', validateCreateTodo, (req, res) => {
  try {
    const { title } = req.validatedData; // Use validated data

    // Check for duplicates
    const exists = todos.find(
      todo => todo.title.toLowerCase() === title.toLowerCase()
    );

    if (exists) {
      return res.status(409).json({
        success: false,
        message: 'Ya existe un todo con ese t√≠tulo',
        errors: {
          title: ['T√≠tulo duplicado'],
        },
        field: 'title',
      });
    }

    const newTodo = {
      id: Date.now(),
      title,
      completed: false,
      createdAt: new Date().toISOString(),
    };

    todos.push(newTodo);

    res.status(201).json({
      success: true,
      message: 'Todo creado exitosamente',
      data: newTodo,
    });
  } catch (error) {
    console.error('‚ùå Create todo error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor',
      error:
        process.env.NODE_ENV === 'development'
          ? error.message
          : 'Error interno',
    });
  }
});

app.put('/api/todos/:id', validateUpdateTodo, (req, res) => {
  try {
    const { id, title, completed } = req.validatedData;

    const todoIndex = todos.findIndex(todo => todo.id === id);

    if (todoIndex === -1) {
      return res.status(404).json({
        success: false,
        message: 'Todo no encontrado',
        errors: {
          id: ['Todo con ese ID no existe'],
        },
      });
    }

    // Check for duplicate title (excluding current todo)
    if (title) {
      const exists = todos.find(
        todo =>
          todo.id !== id && todo.title.toLowerCase() === title.toLowerCase()
      );

      if (exists) {
        return res.status(409).json({
          success: false,
          message: 'Ya existe otro todo con ese t√≠tulo',
          errors: {
            title: ['T√≠tulo duplicado'],
          },
          field: 'title',
        });
      }

      todos[todoIndex].title = title;
    }

    if (completed !== undefined) {
      todos[todoIndex].completed = completed;
    }

    todos[todoIndex].updatedAt = new Date().toISOString();

    res.json({
      success: true,
      message: 'Todo actualizado exitosamente',
      data: todos[todoIndex],
    });
  } catch (error) {
    console.error('‚ùå Update todo error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor',
      error:
        process.env.NODE_ENV === 'development'
          ? error.message
          : 'Error interno',
    });
  }
});

app.delete('/api/todos/:id', validateTodoId, (req, res) => {
  try {
    const { id } = req.validatedData;

    const todoIndex = todos.findIndex(todo => todo.id === id);

    if (todoIndex === -1) {
      return res.status(404).json({
        success: false,
        message: 'Todo no encontrado',
        errors: {
          id: ['Todo con ese ID no existe'],
        },
      });
    }

    const deletedTodo = todos.splice(todoIndex, 1)[0];

    res.json({
      success: true,
      message: 'Todo eliminado exitosamente',
      data: deletedTodo,
    });
  } catch (error) {
    console.error('‚ùå Delete todo error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor',
      error:
        process.env.NODE_ENV === 'development'
          ? error.message
          : 'Error interno',
    });
  }
});

// ... rest of server code
```

---

## ‚ö° FASE ENHANCED (25-50 min) - Frontend Validation

### ‚úÖ Objetivo: UX validation con feedback inmediato

**Frontend Validation Hook (frontend/src/hooks/useFormValidation.js):**

```jsx
import { useState, useCallback } from 'react';

export const useFormValidation = (initialValues = {}, validationRules = {}) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  // üîß Validation functions
  const validateField = useCallback(
    (name, value) => {
      const rules = validationRules[name];
      if (!rules) return [];

      const errors = [];

      // Required validation
      if (rules.required && (!value || value.toString().trim() === '')) {
        errors.push(`${rules.label || name} es requerido`);
        return errors; // Return early for required fields
      }

      // Skip other validations if field is empty and not required
      if (!value || value.toString().trim() === '') {
        return errors;
      }

      const trimmedValue = value.toString().trim();

      // Min length validation
      if (rules.minLength && trimmedValue.length < rules.minLength) {
        errors.push(
          `${rules.label || name} debe tener al menos ${
            rules.minLength
          } caracteres`
        );
      }

      // Max length validation
      if (rules.maxLength && trimmedValue.length > rules.maxLength) {
        errors.push(
          `${rules.label || name} no puede exceder ${
            rules.maxLength
          } caracteres`
        );
      }

      // Pattern validation
      if (rules.pattern && !rules.pattern.test(trimmedValue)) {
        errors.push(
          rules.patternMessage ||
            `${rules.label || name} tiene un formato inv√°lido`
        );
      }

      // Custom validation
      if (rules.custom) {
        const customError = rules.custom(trimmedValue, values);
        if (customError) {
          errors.push(customError);
        }
      }

      return errors;
    },
    [validationRules, values]
  );

  // üîÑ Handle field change
  const handleChange = useCallback(
    (name, value) => {
      setValues(prev => ({
        ...prev,
        [name]: value,
      }));

      // Validate immediately if field has been touched
      if (touched[name]) {
        const fieldErrors = validateField(name, value);
        setErrors(prev => ({
          ...prev,
          [name]: fieldErrors,
        }));
      }
    },
    [validateField, touched]
  );

  // üëÜ Handle field blur
  const handleBlur = useCallback(
    name => {
      setTouched(prev => ({
        ...prev,
        [name]: true,
      }));

      const value = values[name];
      const fieldErrors = validateField(name, value);
      setErrors(prev => ({
        ...prev,
        [name]: fieldErrors,
      }));
    },
    [values, validateField]
  );

  // ‚úÖ Validate all fields
  const validateAll = useCallback(() => {
    const newErrors = {};
    let isValid = true;

    Object.keys(validationRules).forEach(name => {
      const fieldErrors = validateField(name, values[name]);
      newErrors[name] = fieldErrors;
      if (fieldErrors.length > 0) {
        isValid = false;
      }
    });

    setErrors(newErrors);
    setTouched(
      Object.keys(validationRules).reduce(
        (acc, name) => ({
          ...acc,
          [name]: true,
        }),
        {}
      )
    );

    return isValid;
  }, [validationRules, values, validateField]);

  // üßπ Reset form
  const reset = useCallback(
    (newValues = initialValues) => {
      setValues(newValues);
      setErrors({});
      setTouched({});
      setIsSubmitting(false);
    },
    [initialValues]
  );

  // üöÄ Handle form submission
  const handleSubmit = useCallback(
    async onSubmit => {
      setIsSubmitting(true);

      try {
        const isValid = validateAll();

        if (isValid) {
          await onSubmit(values);
          // Don't reset here - let the parent component decide
        }
      } catch (error) {
        console.error('Form submission error:', error);
        throw error;
      } finally {
        setIsSubmitting(false);
      }
    },
    [values, validateAll]
  );

  // üîç Get field helpers
  const getFieldProps = useCallback(
    name => ({
      value: values[name] || '',
      onChange: e => handleChange(name, e.target.value),
      onBlur: () => handleBlur(name),
      error: errors[name] && errors[name].length > 0 ? errors[name][0] : '',
      hasError: touched[name] && errors[name] && errors[name].length > 0,
      isValid: touched[name] && (!errors[name] || errors[name].length === 0),
    }),
    [values, errors, touched, handleChange, handleBlur]
  );

  return {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    validateAll,
    reset,
    handleSubmit,
    getFieldProps,
    isValid: Object.keys(errors).every(
      key => !errors[key] || errors[key].length === 0
    ),
  };
};

// üéØ Todo validation rules
export const todoValidationRules = {
  title: {
    label: 'T√≠tulo',
    required: true,
    minLength: 3,
    maxLength: 100,
    pattern: /^[^<>"'&]*$/, // No HTML characters
    patternMessage:
      'El t√≠tulo no puede contener caracteres especiales (<, >, ", \', &)',
    custom: (value, allValues) => {
      // Add any custom validation logic here
      if (value && value.toLowerCase().includes('spam')) {
        return 'El t√≠tulo no puede contener contenido inapropiado';
      }
      return null;
    },
  },
};
```

**Enhanced Form Component (frontend/src/components/AddTodoForm.jsx):**

```jsx
import { useState } from 'react';
import { useTodos } from '../contexts/TodoContext';
import {
  useFormValidation,
  todoValidationRules,
} from '../hooks/useFormValidation';

const AddTodoForm = () => {
  const { addTodo } = useTodos();
  const [submitError, setSubmitError] = useState(null);

  const { values, handleSubmit, getFieldProps, reset, isSubmitting, isValid } =
    useFormValidation({ title: '' }, todoValidationRules);

  const onSubmit = async formData => {
    try {
      setSubmitError(null);
      await addTodo(formData.title);
      reset(); // Clear form on success
    } catch (error) {
      // Handle backend validation errors
      if (error.response && error.response.data && error.response.data.errors) {
        const backendErrors = error.response.data.errors;
        if (backendErrors.title) {
          setSubmitError(backendErrors.title[0]);
        }
      } else {
        setSubmitError(error.message || 'Error al crear el todo');
      }
      throw error; // Re-throw to prevent form reset
    }
  };

  const titleProps = getFieldProps('title');

  return (
    <div className="add-todo-section">
      <h2>‚ûï Agregar Nuevo Todo</h2>

      <form
        onSubmit={e => {
          e.preventDefault();
          handleSubmit(onSubmit);
        }}
        className="add-todo-form"
        noValidate>
        <div className="form-group">
          <div className="input-wrapper">
            <input
              type="text"
              placeholder="Escriba su nuevo todo..."
              className={`add-todo-input ${
                titleProps.hasError
                  ? 'error'
                  : titleProps.isValid
                  ? 'valid'
                  : ''
              }`}
              disabled={isSubmitting}
              {...titleProps}
            />

            <div className="input-feedback">
              {titleProps.hasError && (
                <span className="error-message">‚ùå {titleProps.error}</span>
              )}

              {titleProps.isValid && (
                <span className="success-message">‚úÖ T√≠tulo v√°lido</span>
              )}
            </div>
          </div>

          <button
            type="submit"
            className="add-todo-btn"
            disabled={isSubmitting || !isValid || !values.title.trim()}>
            {isSubmitting ? (
              <>
                <div className="loading-spinner small"></div>
                Agregando...
              </>
            ) : (
              '‚ûï Agregar Todo'
            )}
          </button>
        </div>

        {submitError && (
          <div className="submit-error">
            <span>‚ùå {submitError}</span>
          </div>
        )}

        {/* Character counter */}
        <div className="form-meta">
          <span
            className={`char-counter ${
              values.title.length > 80 ? 'warning' : ''
            }`}>
            {values.title.length}/100 caracteres
          </span>
        </div>
      </form>
    </div>
  );
};

export default AddTodoForm;
```

---

## ‚ú® FASE POLISH (50-60 min) - Advanced Security

### ‚úÖ Objetivo: Security patterns + accessibility

**Security Enhancements:**

```javascript
// backend/middleware/security.js
const helmet = require('helmet');
const xss = require('xss');

// XSS Protection
const sanitizeInput = (req, res, next) => {
  if (req.body) {
    Object.keys(req.body).forEach(key => {
      if (typeof req.body[key] === 'string') {
        req.body[key] = xss(req.body[key]);
      }
    });
  }
  next();
};

// Content Security Policy
app.use(
  helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        scriptSrc: ["'self'", "'unsafe-inline'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        imgSrc: ["'self'", 'data:', 'https:'],
      },
    },
  })
);

module.exports = { sanitizeInput };
```

**Accessibility Enhancements:**

```jsx
// Accessible form component
const AccessibleInput = ({ label, error, isValid, required, ...props }) => {
  const inputId = `input-${props.name}`;
  const errorId = `error-${props.name}`;

  return (
    <div className="form-field">
      <label
        htmlFor={inputId}
        className="form-label">
        {label}
        {required && (
          <span
            className="required"
            aria-label="required">
            *
          </span>
        )}
      </label>

      <input
        id={inputId}
        aria-describedby={error ? errorId : undefined}
        aria-invalid={error ? 'true' : 'false'}
        className={`form-input ${error ? 'error' : isValid ? 'valid' : ''}`}
        {...props}
      />

      {error && (
        <div
          id={errorId}
          className="error-message"
          role="alert">
          {error}
        </div>
      )}
    </div>
  );
};
```

---

## üéØ VALIDACI√ìN FINAL

### ‚úÖ Checklist Core (CORE MVP)

- [ ] ‚úÖ Backend validation middleware funcionando
- [ ] ‚úÖ API error responses estructuradas
- [ ] ‚úÖ Rate limiting implementado
- [ ] ‚úÖ XSS protection b√°sica
- [ ] ‚úÖ Input sanitization funcionando

### ‚ö° Checklist Enhanced (ENHANCED MVP)

- [ ] ‚ö° Frontend validation hook completo
- [ ] ‚ö° Real-time validation feedback
- [ ] ‚ö° Error message customization
- [ ] ‚ö° Form state management robusto
- [ ] ‚ö° UX feedback inmediato

### ‚ú® Checklist Polish (POLISH MVP)

- [ ] ‚ú® Security headers implementados
- [ ] ‚ú® Accessibility compliance
- [ ] ‚ú® Advanced XSS protection
- [ ] ‚ú® Content Security Policy
- [ ] ‚ú® Input validation comprehensive

---

## üö® SECURITY CHECKLIST

### üîí Backend Security

- ‚úÖ Input validation & sanitization
- ‚úÖ Rate limiting
- ‚úÖ XSS protection
- ‚úÖ SQL injection prevention
- ‚úÖ Error message sanitization

### üõ°Ô∏è Frontend Security

- ‚úÖ Client-side validation
- ‚úÖ XSS prevention in display
- ‚úÖ Input encoding
- ‚úÖ HTTPS enforcement
- ‚úÖ Secure headers

---

## ‚è≠Ô∏è RESULTADO

**Enhanced Validation System completado:**

- ‚úÖ Backend validation robusta
- ‚úÖ Frontend UX validation
- ‚úÖ Security patterns implementados
- ‚úÖ Accessibility compliance
- ‚úÖ Production security ready

**Tiempo objetivo**: ‚úÖ **Completado en 60 minutos**

**Pr√≥ximo**: `07-polish-ux` - Final UX optimizations

---

## üìã RESUMEN EJECUTIVO

### üéØ ¬øQu√© Logramos?

- Sistema de validaci√≥n completo
- Security layer robusto
- UX feedback profesional
- Accessibility compliance

### ‚è∞ Time Investment

- **Backend Validation**: 25 min
- **Frontend UX**: 25 min
- **Security Polish**: 10 min
- **Total**: 60 min ‚úÖ

**üèÜ Enhanced Validation completado - ENTERPRISE READY!**
